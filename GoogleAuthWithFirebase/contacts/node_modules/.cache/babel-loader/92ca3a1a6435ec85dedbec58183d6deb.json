{"ast":null,"code":"/**\n * @todo: recursively send requests until all contacts are fetched\n *\n * @see https://developers.google.com/google-apps/contacts/v3/reference#ContactsFeed\n *\n * To API test requests: \n *\n * @see https://developers.google.com/oauthplayground/\n *\n * To format JSON nicely:\n *\n * @see http://jsonviewer.stack.hu/\n *\n * Note: The Contacts API has a hard limit to the number of results it can return at a \n * time even if you explicitly request all possible results. If the requested feed has \n * more fields than can be returned in a single response, the API truncates the feed and adds \n * a \"Next\" link that allows you to request the rest of the response.\n */\nvar EventEmitter = require('events').EventEmitter,\n    qs = require('querystring'),\n    util = require('util'),\n    url = require('url'),\n    https = require('https'),\n    _ = require('lodash');\n\nvar GoogleContacts = function GoogleContacts(opts) {\n  if (typeof opts === 'string') {\n    opts = {\n      token: opts\n    };\n  }\n\n  if (!opts) {\n    opts = {};\n  }\n\n  this.contacts = [];\n  this.consumerKey = opts.consumerKey ? opts.consumerKey : null;\n  this.consumerSecret = opts.consumerSecret ? opts.consumerSecret : null;\n  this.token = opts.token ? opts.token : null;\n  this.refreshToken = opts.refreshToken ? opts.refreshToken : null;\n};\n\nGoogleContacts.prototype = {};\nutil.inherits(GoogleContacts, EventEmitter);\n\nGoogleContacts.prototype._get = function (params, cb) {\n  var self = this;\n\n  if (typeof params === 'function') {\n    cb = params;\n    params = {};\n  }\n\n  var req = {\n    host: 'www.google.com',\n    port: 443,\n    path: this._buildPath(params),\n    method: 'GET',\n    headers: {\n      'Authorization': 'Bearer ' + this.token\n    }\n  };\n  https.request(req, function (res) {\n    var data = '';\n    res.on('end', function () {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        var error = new Error('Bad client request status: ' + res.statusCode);\n        return cb(error);\n      }\n\n      try {\n        data = JSON.parse(data);\n        cb(null, data);\n      } catch (err) {\n        cb(err);\n      }\n    });\n    res.on('data', function (chunk) {\n      data += chunk;\n    });\n    res.on('error', function (err) {\n      cb(err);\n    });\n  }).on('error', function (err) {\n    cb(err);\n  }).end();\n};\n\nGoogleContacts.prototype.getContacts = function (params, cb, contacts) {\n  var self = this;\n\n  if (typeof params == \"function\") {\n    cb = params;\n    params = {};\n  }\n\n  this._get(params, receivedContacts);\n\n  function receivedContacts(err, data) {\n    if (err) return cb(err);\n\n    self._saveContactsFromFeed(data.feed, params);\n\n    var next = false;\n    data.feed.link.forEach(function (link) {\n      if (link.rel === 'next') {\n        next = true;\n        var path = url.parse(link.href).path;\n\n        self._get(_.extend(params, {\n          path: path\n        }), receivedContacts);\n      }\n    });\n\n    if (!next) {\n      cb(null, self.contacts);\n    }\n  }\n\n  ;\n}; // grab a property off an entry\n\n\nfunction val(entry, name, attr, delimiter) {\n  if (!entry[name]) return;\n\n  if (!Array.isArray(entry[name])) {\n    return entry[name][attr];\n  } else if (delimiter) {\n    return entry[name].map(function (item) {\n      return {\n        label: item.rel ? item.rel.split(delimiter)[1] : \"default\",\n        field: item[attr]\n      };\n    });\n  } else {\n    return entry[name][0][attr];\n  }\n}\n\nvar processors = {\n  'thin': function thin(contacts) {\n    return function (entry) {\n      contacts.push({\n        name: val(entry, 'title', '$t'),\n        email: val(entry, 'gd$email', 'address')\n      });\n    };\n  },\n  'full': function full(contacts) {\n    return function (entry) {\n      contacts.push({\n        name: val(entry, 'title', '$t'),\n        email: val(entry, 'gd$email', 'address'),\n        phones: val(entry, 'gd$phoneNumber', '$t', '#')\n      });\n    };\n  },\n  'custom': function custom(contacts, projection) {\n    // pull apart the properties\n    var props = projection.split(',').map(function (prop) {\n      return prop.replace('property-', '');\n    }); // always include name\n\n    props.unshift(\"name\"); // https://developers.google.com/google-apps/contacts/v3/reference#ProjectionsAndExtended\n    // a map of property names to places on the contact\n\n    var prop_names = {\n      \"name\": \"title\",\n      \"email\": \"gd$email\",\n      \"phoneNumber\": \"gd$phoneNumber\"\n    };\n    var prop_attr = {\n      \"name\": \"$t\",\n      \"email\": \"address\",\n      \"phoneNumber\": \"$t\" // generating a collection of functions\n\n    };\n    var objector = {};\n\n    _.each(props, function (prop) {\n      objector[prop] = _.partialRight(val, prop_names[prop], prop_attr[prop]);\n    });\n\n    return function (entry) {\n      var obj = {};\n\n      _.each(props, function (prop) {\n        obj[prop] = objector[prop](entry);\n      });\n\n      contacts.push(obj);\n    };\n  }\n};\n\nGoogleContacts.prototype._saveContactsFromFeed = function (feed, params) {\n  var self = this; // detect which type of projection is being used\n\n  var processor; // dynamic detection of processor type\n\n  if (processors[params.projection]) {\n    processor = processors[params.projection](self.contacts);\n  } else {\n    processor = processors.custom(self.contacts, params.projection);\n  } // run the processor over each entry\n\n\n  feed.entry.forEach(processor);\n};\n\nGoogleContacts.prototype._buildPath = function (params) {\n  params = _.defaults(params, {\n    type: 'contacts',\n    alt: 'json',\n    projection: 'thin',\n    email: 'default',\n    'max-results': 2000\n  });\n  if (params.path) return params.path;\n  var query = {\n    alt: params.alt,\n    'max-results': params['max-results']\n  };\n  var path = '/m8/feeds/';\n  path += params.type + '/';\n  path += params.email + '/';\n  path += params.projection;\n  path += '?' + qs.stringify(query);\n  return path;\n};\n\nGoogleContacts.prototype.refreshAccessToken = function (refreshToken, cb) {\n  if (typeof params === 'function') {\n    cb = params;\n    params = {};\n  }\n\n  var data = {\n    refresh_token: refreshToken,\n    client_id: this.consumerKey,\n    client_secret: this.consumerSecret,\n    grant_type: 'refresh_token'\n  };\n  var body = qs.stringify(data);\n  var opts = {\n    host: 'accounts.google.com',\n    port: 443,\n    path: '/o/oauth2/token',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': body.length\n    }\n  };\n  var req = https.request(opts, function (res) {\n    var data = '';\n    res.on('end', function () {\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        var error = new Error('Bad client request status: ' + res.statusCode);\n        return cb(error);\n      }\n\n      try {\n        data = JSON.parse(data);\n        cb(null, data.access_token);\n      } catch (err) {\n        cb(err);\n      }\n    });\n    res.on('data', function (chunk) {\n      data += chunk;\n    });\n    res.on('error', function (err) {\n      cb(err);\n    }); //res.on('close', onFinish);\n  }).on('error', function (err) {\n    cb(err);\n  });\n  req.write(body);\n  req.end();\n};\n\nmodule.exports = GoogleContacts;","map":null,"metadata":{},"sourceType":"script"}